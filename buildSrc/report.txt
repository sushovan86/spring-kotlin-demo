
> Task :kotlinDslAccessorsReport

    /**
     * Retrieves the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    val org.gradle.api.Project.`ext`: org.gradle.api.plugins.ExtraPropertiesExtension get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("ext") as org.gradle.api.plugins.ExtraPropertiesExtension
    
    /**
     * Configures the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    fun org.gradle.api.Project.`ext`(configure: org.gradle.api.plugins.ExtraPropertiesExtension.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("ext", configure)


    /**
     * Retrieves the [defaultArtifacts][org.gradle.api.internal.plugins.DefaultArtifactPublicationSet] extension.
     */
    val org.gradle.api.Project.`defaultArtifacts`: org.gradle.api.internal.plugins.DefaultArtifactPublicationSet get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("defaultArtifacts") as org.gradle.api.internal.plugins.DefaultArtifactPublicationSet
    
    /**
     * Configures the [defaultArtifacts][org.gradle.api.internal.plugins.DefaultArtifactPublicationSet] extension.
     */
    fun org.gradle.api.Project.`defaultArtifacts`(configure: org.gradle.api.internal.plugins.DefaultArtifactPublicationSet.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("defaultArtifacts", configure)


    /**
     * Retrieves the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    val org.gradle.api.internal.plugins.DefaultArtifactPublicationSet.`ext`: org.gradle.api.plugins.ExtraPropertiesExtension get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("ext") as org.gradle.api.plugins.ExtraPropertiesExtension
    
    /**
     * Configures the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    fun org.gradle.api.internal.plugins.DefaultArtifactPublicationSet.`ext`(configure: org.gradle.api.plugins.ExtraPropertiesExtension.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("ext", configure)


    /**
     * Retrieves the [reporting][org.gradle.api.reporting.ReportingExtension] extension.
     */
    val org.gradle.api.Project.`reporting`: org.gradle.api.reporting.ReportingExtension get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("reporting") as org.gradle.api.reporting.ReportingExtension
    
    /**
     * Configures the [reporting][org.gradle.api.reporting.ReportingExtension] extension.
     */
    fun org.gradle.api.Project.`reporting`(configure: org.gradle.api.reporting.ReportingExtension.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("reporting", configure)


    /**
     * Retrieves the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    val org.gradle.api.reporting.ReportingExtension.`ext`: org.gradle.api.plugins.ExtraPropertiesExtension get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("ext") as org.gradle.api.plugins.ExtraPropertiesExtension
    
    /**
     * Configures the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    fun org.gradle.api.reporting.ReportingExtension.`ext`(configure: org.gradle.api.plugins.ExtraPropertiesExtension.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("ext", configure)


    /**
     * Retrieves the [sourceSets][org.gradle.api.tasks.SourceSetContainer] extension.
     */
    val org.gradle.api.Project.`sourceSets`: org.gradle.api.tasks.SourceSetContainer get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("sourceSets") as org.gradle.api.tasks.SourceSetContainer
    
    /**
     * Configures the [sourceSets][org.gradle.api.tasks.SourceSetContainer] extension.
     */
    fun org.gradle.api.Project.`sourceSets`(configure: org.gradle.api.tasks.SourceSetContainer.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("sourceSets", configure)


    /**
     * Retrieves the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    val org.gradle.api.tasks.SourceSetContainer.`ext`: org.gradle.api.plugins.ExtraPropertiesExtension get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("ext") as org.gradle.api.plugins.ExtraPropertiesExtension
    
    /**
     * Configures the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    fun org.gradle.api.tasks.SourceSetContainer.`ext`(configure: org.gradle.api.plugins.ExtraPropertiesExtension.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("ext", configure)


    /**
     * Retrieves the [java][org.gradle.api.plugins.JavaPluginExtension] extension.
     */
    val org.gradle.api.Project.`java`: org.gradle.api.plugins.JavaPluginExtension get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("java") as org.gradle.api.plugins.JavaPluginExtension
    
    /**
     * Configures the [java][org.gradle.api.plugins.JavaPluginExtension] extension.
     */
    fun org.gradle.api.Project.`java`(configure: org.gradle.api.plugins.JavaPluginExtension.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("java", configure)


    /**
     * Retrieves the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    val org.gradle.api.plugins.JavaPluginExtension.`ext`: org.gradle.api.plugins.ExtraPropertiesExtension get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("ext") as org.gradle.api.plugins.ExtraPropertiesExtension
    
    /**
     * Configures the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    fun org.gradle.api.plugins.JavaPluginExtension.`ext`(configure: org.gradle.api.plugins.ExtraPropertiesExtension.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("ext", configure)


    /**
     * Retrieves the [javaInstalls][org.gradle.jvm.toolchain.JavaInstallationRegistry] extension.
     */
    val org.gradle.api.Project.`javaInstalls`: org.gradle.jvm.toolchain.JavaInstallationRegistry get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("javaInstalls") as org.gradle.jvm.toolchain.JavaInstallationRegistry
    
    /**
     * Configures the [javaInstalls][org.gradle.jvm.toolchain.JavaInstallationRegistry] extension.
     */
    fun org.gradle.api.Project.`javaInstalls`(configure: org.gradle.jvm.toolchain.JavaInstallationRegistry.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("javaInstalls", configure)


    /**
     * Retrieves the [gradlePlugin][org.gradle.plugin.devel.GradlePluginDevelopmentExtension] extension.
     */
    val org.gradle.api.Project.`gradlePlugin`: org.gradle.plugin.devel.GradlePluginDevelopmentExtension get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("gradlePlugin") as org.gradle.plugin.devel.GradlePluginDevelopmentExtension
    
    /**
     * Configures the [gradlePlugin][org.gradle.plugin.devel.GradlePluginDevelopmentExtension] extension.
     */
    fun org.gradle.api.Project.`gradlePlugin`(configure: org.gradle.plugin.devel.GradlePluginDevelopmentExtension.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("gradlePlugin", configure)


    /**
     * Retrieves the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    val org.gradle.plugin.devel.GradlePluginDevelopmentExtension.`ext`: org.gradle.api.plugins.ExtraPropertiesExtension get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("ext") as org.gradle.api.plugins.ExtraPropertiesExtension
    
    /**
     * Configures the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    fun org.gradle.plugin.devel.GradlePluginDevelopmentExtension.`ext`(configure: org.gradle.api.plugins.ExtraPropertiesExtension.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("ext", configure)


    /**
     * Retrieves the [kotlin][org.jetbrains.kotlin.gradle.dsl.KotlinJvmProjectExtension] extension.
     */
    val org.gradle.api.Project.`kotlin`: org.jetbrains.kotlin.gradle.dsl.KotlinJvmProjectExtension get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("kotlin") as org.jetbrains.kotlin.gradle.dsl.KotlinJvmProjectExtension
    
    /**
     * Configures the [kotlin][org.jetbrains.kotlin.gradle.dsl.KotlinJvmProjectExtension] extension.
     */
    fun org.gradle.api.Project.`kotlin`(configure: org.jetbrains.kotlin.gradle.dsl.KotlinJvmProjectExtension.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("kotlin", configure)


    /**
     * Retrieves the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    val org.jetbrains.kotlin.gradle.dsl.KotlinJvmProjectExtension.`ext`: org.gradle.api.plugins.ExtraPropertiesExtension get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("ext") as org.gradle.api.plugins.ExtraPropertiesExtension
    
    /**
     * Configures the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    fun org.jetbrains.kotlin.gradle.dsl.KotlinJvmProjectExtension.`ext`(configure: org.gradle.api.plugins.ExtraPropertiesExtension.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("ext", configure)


    /**
     * Retrieves the [experimental][org.jetbrains.kotlin.gradle.dsl.ExperimentalExtension] extension.
     */
    val org.jetbrains.kotlin.gradle.dsl.KotlinJvmProjectExtension.`experimental`: org.jetbrains.kotlin.gradle.dsl.ExperimentalExtension get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("experimental") as org.jetbrains.kotlin.gradle.dsl.ExperimentalExtension
    
    /**
     * Configures the [experimental][org.jetbrains.kotlin.gradle.dsl.ExperimentalExtension] extension.
     */
    fun org.jetbrains.kotlin.gradle.dsl.KotlinJvmProjectExtension.`experimental`(configure: org.jetbrains.kotlin.gradle.dsl.ExperimentalExtension.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("experimental", configure)


    /**
     * Retrieves the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    val org.jetbrains.kotlin.gradle.dsl.ExperimentalExtension.`ext`: org.gradle.api.plugins.ExtraPropertiesExtension get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("ext") as org.gradle.api.plugins.ExtraPropertiesExtension
    
    /**
     * Configures the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    fun org.jetbrains.kotlin.gradle.dsl.ExperimentalExtension.`ext`(configure: org.gradle.api.plugins.ExtraPropertiesExtension.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("ext", configure)


    /**
     * Retrieves the [sourceSets][org.gradle.api.NamedDomainObjectContainer<org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet>] extension.
     */
    val org.jetbrains.kotlin.gradle.dsl.KotlinJvmProjectExtension.`sourceSets`: org.gradle.api.NamedDomainObjectContainer<org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet> get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("sourceSets") as org.gradle.api.NamedDomainObjectContainer<org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet>
    
    /**
     * Configures the [sourceSets][org.gradle.api.NamedDomainObjectContainer<org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet>] extension.
     */
    fun org.jetbrains.kotlin.gradle.dsl.KotlinJvmProjectExtension.`sourceSets`(configure: org.gradle.api.NamedDomainObjectContainer<org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet>.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("sourceSets", configure)


    /**
     * Retrieves the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet>.`ext`: org.gradle.api.plugins.ExtraPropertiesExtension get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("ext") as org.gradle.api.plugins.ExtraPropertiesExtension
    
    /**
     * Configures the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    fun org.gradle.api.NamedDomainObjectContainer<org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet>.`ext`(configure: org.gradle.api.plugins.ExtraPropertiesExtension.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("ext", configure)


    /**
     * Retrieves the [kotlinTestRegistry][org.jetbrains.kotlin.gradle.testing.internal.KotlinTestsRegistry] extension.
     */
    val org.gradle.api.Project.`kotlinTestRegistry`: org.jetbrains.kotlin.gradle.testing.internal.KotlinTestsRegistry get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("kotlinTestRegistry") as org.jetbrains.kotlin.gradle.testing.internal.KotlinTestsRegistry
    
    /**
     * Configures the [kotlinTestRegistry][org.jetbrains.kotlin.gradle.testing.internal.KotlinTestsRegistry] extension.
     */
    fun org.gradle.api.Project.`kotlinTestRegistry`(configure: org.jetbrains.kotlin.gradle.testing.internal.KotlinTestsRegistry.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("kotlinTestRegistry", configure)


    /**
     * Retrieves the [kotlinDslPluginOptions][org.gradle.kotlin.dsl.plugins.dsl.KotlinDslPluginOptions] extension.
     */
    val org.gradle.api.Project.`kotlinDslPluginOptions`: org.gradle.kotlin.dsl.plugins.dsl.KotlinDslPluginOptions get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("kotlinDslPluginOptions") as org.gradle.kotlin.dsl.plugins.dsl.KotlinDslPluginOptions
    
    /**
     * Configures the [kotlinDslPluginOptions][org.gradle.kotlin.dsl.plugins.dsl.KotlinDslPluginOptions] extension.
     */
    fun org.gradle.api.Project.`kotlinDslPluginOptions`(configure: org.gradle.kotlin.dsl.plugins.dsl.KotlinDslPluginOptions.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("kotlinDslPluginOptions", configure)


    /**
     * Retrieves the [samWithReceiver][org.jetbrains.kotlin.samWithReceiver.gradle.SamWithReceiverExtension] extension.
     */
    val org.gradle.api.Project.`samWithReceiver`: org.jetbrains.kotlin.samWithReceiver.gradle.SamWithReceiverExtension get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("samWithReceiver") as org.jetbrains.kotlin.samWithReceiver.gradle.SamWithReceiverExtension
    
    /**
     * Configures the [samWithReceiver][org.jetbrains.kotlin.samWithReceiver.gradle.SamWithReceiverExtension] extension.
     */
    fun org.gradle.api.Project.`samWithReceiver`(configure: org.jetbrains.kotlin.samWithReceiver.gradle.SamWithReceiverExtension.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("samWithReceiver", configure)


    /**
     * Retrieves the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    val org.jetbrains.kotlin.samWithReceiver.gradle.SamWithReceiverExtension.`ext`: org.gradle.api.plugins.ExtraPropertiesExtension get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("ext") as org.gradle.api.plugins.ExtraPropertiesExtension
    
    /**
     * Configures the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    fun org.jetbrains.kotlin.samWithReceiver.gradle.SamWithReceiverExtension.`ext`(configure: org.gradle.api.plugins.ExtraPropertiesExtension.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("ext", configure)


    /**
     * Retrieves the [kotlinScripting][org.jetbrains.kotlin.gradle.scripting.ScriptingExtension] extension.
     */
    val org.gradle.api.Project.`kotlinScripting`: org.jetbrains.kotlin.gradle.scripting.ScriptingExtension get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("kotlinScripting") as org.jetbrains.kotlin.gradle.scripting.ScriptingExtension
    
    /**
     * Configures the [kotlinScripting][org.jetbrains.kotlin.gradle.scripting.ScriptingExtension] extension.
     */
    fun org.gradle.api.Project.`kotlinScripting`(configure: org.jetbrains.kotlin.gradle.scripting.ScriptingExtension.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("kotlinScripting", configure)


    /**
     * Retrieves the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    val org.jetbrains.kotlin.gradle.scripting.ScriptingExtension.`ext`: org.gradle.api.plugins.ExtraPropertiesExtension get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("ext") as org.gradle.api.plugins.ExtraPropertiesExtension
    
    /**
     * Configures the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    fun org.jetbrains.kotlin.gradle.scripting.ScriptingExtension.`ext`(configure: org.gradle.api.plugins.ExtraPropertiesExtension.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("ext", configure)


    /**
     * Retrieves the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    val org.gradle.api.artifacts.dsl.DependencyHandler.`ext`: org.gradle.api.plugins.ExtraPropertiesExtension get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("ext") as org.gradle.api.plugins.ExtraPropertiesExtension
    
    /**
     * Configures the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    fun org.gradle.api.artifacts.dsl.DependencyHandler.`ext`(configure: org.gradle.api.plugins.ExtraPropertiesExtension.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("ext", configure)


    /**
     * Retrieves the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    val org.gradle.api.tasks.SourceSet.`ext`: org.gradle.api.plugins.ExtraPropertiesExtension get() =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.getByName("ext") as org.gradle.api.plugins.ExtraPropertiesExtension
    
    /**
     * Configures the [ext][org.gradle.api.plugins.ExtraPropertiesExtension] extension.
     */
    fun org.gradle.api.tasks.SourceSet.`ext`(configure: org.gradle.api.plugins.ExtraPropertiesExtension.() -> Unit): Unit =
        (this as org.gradle.api.plugins.ExtensionAware).extensions.configure("ext", configure)


    /**
     * Retrieves the [base][org.gradle.api.plugins.BasePluginConvention] convention.
     */
    val org.gradle.api.Project.`base`: org.gradle.api.plugins.BasePluginConvention get() =
        ((this as? Project)?.convention ?: (this as org.gradle.api.internal.HasConvention).convention).getPluginByName<org.gradle.api.plugins.BasePluginConvention>("base")
    
    /**
     * Configures the [base][org.gradle.api.plugins.BasePluginConvention] convention.
     */
    fun org.gradle.api.Project.`base`(configure: org.gradle.api.plugins.BasePluginConvention.() -> Unit): Unit =
        configure(`base`)
    


    /**
     * Provides the existing [classes][org.gradle.api.DefaultTask] task.
     */
    val TaskContainer.`classes`: TaskProvider<org.gradle.api.DefaultTask>
        get() = named<org.gradle.api.DefaultTask>("classes")
    


    /**
     * Provides the existing [compileJava][org.gradle.api.tasks.compile.JavaCompile] task.
     */
    val TaskContainer.`compileJava`: TaskProvider<org.gradle.api.tasks.compile.JavaCompile>
        get() = named<org.gradle.api.tasks.compile.JavaCompile>("compileJava")
    


    /**
     * Provides the existing [compileKotlin][org.jetbrains.kotlin.gradle.tasks.KotlinCompile] task.
     */
    val TaskContainer.`compileKotlin`: TaskProvider<org.jetbrains.kotlin.gradle.tasks.KotlinCompile>
        get() = named<org.jetbrains.kotlin.gradle.tasks.KotlinCompile>("compileKotlin")
    


    /**
     * Provides the existing [compileTestJava][org.gradle.api.tasks.compile.JavaCompile] task.
     */
    val TaskContainer.`compileTestJava`: TaskProvider<org.gradle.api.tasks.compile.JavaCompile>
        get() = named<org.gradle.api.tasks.compile.JavaCompile>("compileTestJava")
    


    /**
     * Provides the existing [compileTestKotlin][org.jetbrains.kotlin.gradle.tasks.KotlinCompile] task.
     */
    val TaskContainer.`compileTestKotlin`: TaskProvider<org.jetbrains.kotlin.gradle.tasks.KotlinCompile>
        get() = named<org.jetbrains.kotlin.gradle.tasks.KotlinCompile>("compileTestKotlin")
    


    /**
     * Provides the existing [jar][org.gradle.api.tasks.bundling.Jar] task.
     */
    val TaskContainer.`jar`: TaskProvider<org.gradle.api.tasks.bundling.Jar>
        get() = named<org.gradle.api.tasks.bundling.Jar>("jar")
    


    /**
     * Provides the existing [kotlinDslAccessorsReport][org.gradle.kotlin.dsl.accessors.tasks.PrintAccessors] task.
     */
    val TaskContainer.`kotlinDslAccessorsReport`: TaskProvider<org.gradle.kotlin.dsl.accessors.tasks.PrintAccessors>
        get() = named<org.gradle.kotlin.dsl.accessors.tasks.PrintAccessors>("kotlinDslAccessorsReport")
    


    /**
     * Provides the existing [kotlinSourcesJar][org.gradle.jvm.tasks.Jar] task.
     */
    val TaskContainer.`kotlinSourcesJar`: TaskProvider<org.gradle.jvm.tasks.Jar>
        get() = named<org.gradle.jvm.tasks.Jar>("kotlinSourcesJar")
    


    /**
     * Provides the existing [help][org.gradle.configuration.Help] task.
     */
    val TaskContainer.`help`: TaskProvider<org.gradle.configuration.Help>
        get() = named<org.gradle.configuration.Help>("help")
    


    /**
     * Provides the existing [projects][org.gradle.api.tasks.diagnostics.ProjectReportTask] task.
     */
    val TaskContainer.`projects`: TaskProvider<org.gradle.api.tasks.diagnostics.ProjectReportTask>
        get() = named<org.gradle.api.tasks.diagnostics.ProjectReportTask>("projects")
    


    /**
     * Provides the existing [tasks][org.gradle.api.tasks.diagnostics.TaskReportTask] task.
     */
    val TaskContainer.`tasks`: TaskProvider<org.gradle.api.tasks.diagnostics.TaskReportTask>
        get() = named<org.gradle.api.tasks.diagnostics.TaskReportTask>("tasks")
    


    /**
     * Provides the existing [properties][org.gradle.api.tasks.diagnostics.PropertyReportTask] task.
     */
    val TaskContainer.`properties`: TaskProvider<org.gradle.api.tasks.diagnostics.PropertyReportTask>
        get() = named<org.gradle.api.tasks.diagnostics.PropertyReportTask>("properties")
    


    /**
     * Provides the existing [dependencyInsight][org.gradle.api.tasks.diagnostics.DependencyInsightReportTask] task.
     */
    val TaskContainer.`dependencyInsight`: TaskProvider<org.gradle.api.tasks.diagnostics.DependencyInsightReportTask>
        get() = named<org.gradle.api.tasks.diagnostics.DependencyInsightReportTask>("dependencyInsight")
    


    /**
     * Provides the existing [dependencies][org.gradle.api.tasks.diagnostics.DependencyReportTask] task.
     */
    val TaskContainer.`dependencies`: TaskProvider<org.gradle.api.tasks.diagnostics.DependencyReportTask>
        get() = named<org.gradle.api.tasks.diagnostics.DependencyReportTask>("dependencies")
    


    /**
     * Provides the existing [buildEnvironment][org.gradle.api.tasks.diagnostics.BuildEnvironmentReportTask] task.
     */
    val TaskContainer.`buildEnvironment`: TaskProvider<org.gradle.api.tasks.diagnostics.BuildEnvironmentReportTask>
        get() = named<org.gradle.api.tasks.diagnostics.BuildEnvironmentReportTask>("buildEnvironment")
    


    /**
     * Provides the existing [components][org.gradle.api.reporting.components.ComponentReport] task.
     */
    val TaskContainer.`components`: TaskProvider<org.gradle.api.reporting.components.ComponentReport>
        get() = named<org.gradle.api.reporting.components.ComponentReport>("components")
    


    /**
     * Provides the existing [model][org.gradle.api.reporting.model.ModelReport] task.
     */
    val TaskContainer.`model`: TaskProvider<org.gradle.api.reporting.model.ModelReport>
        get() = named<org.gradle.api.reporting.model.ModelReport>("model")
    


    /**
     * Provides the existing [dependentComponents][org.gradle.api.reporting.dependents.DependentComponentsReport] task.
     */
    val TaskContainer.`dependentComponents`: TaskProvider<org.gradle.api.reporting.dependents.DependentComponentsReport>
        get() = named<org.gradle.api.reporting.dependents.DependentComponentsReport>("dependentComponents")
    


    /**
     * Provides the existing [outgoingVariants][org.gradle.api.tasks.diagnostics.OutgoingVariantsReportTask] task.
     */
    val TaskContainer.`outgoingVariants`: TaskProvider<org.gradle.api.tasks.diagnostics.OutgoingVariantsReportTask>
        get() = named<org.gradle.api.tasks.diagnostics.OutgoingVariantsReportTask>("outgoingVariants")
    


    /**
     * Provides the existing [prepareKotlinBuildScriptModel][org.gradle.api.DefaultTask] task.
     */
    val TaskContainer.`prepareKotlinBuildScriptModel`: TaskProvider<org.gradle.api.DefaultTask>
        get() = named<org.gradle.api.DefaultTask>("prepareKotlinBuildScriptModel")
    


    /**
     * Provides the existing [init][org.gradle.buildinit.tasks.InitBuild] task.
     */
    val TaskContainer.`init`: TaskProvider<org.gradle.buildinit.tasks.InitBuild>
        get() = named<org.gradle.buildinit.tasks.InitBuild>("init")
    


    /**
     * Provides the existing [wrapper][org.gradle.api.tasks.wrapper.Wrapper] task.
     */
    val TaskContainer.`wrapper`: TaskProvider<org.gradle.api.tasks.wrapper.Wrapper>
        get() = named<org.gradle.api.tasks.wrapper.Wrapper>("wrapper")
    


    /**
     * Provides the existing [clean][org.gradle.api.tasks.Delete] task.
     */
    val TaskContainer.`clean`: TaskProvider<org.gradle.api.tasks.Delete>
        get() = named<org.gradle.api.tasks.Delete>("clean")
    


    /**
     * Provides the existing [assemble][org.gradle.api.DefaultTask] task.
     */
    val TaskContainer.`assemble`: TaskProvider<org.gradle.api.DefaultTask>
        get() = named<org.gradle.api.DefaultTask>("assemble")
    


    /**
     * Provides the existing [check][org.gradle.api.DefaultTask] task.
     */
    val TaskContainer.`check`: TaskProvider<org.gradle.api.DefaultTask>
        get() = named<org.gradle.api.DefaultTask>("check")
    


    /**
     * Provides the existing [build][org.gradle.api.DefaultTask] task.
     */
    val TaskContainer.`build`: TaskProvider<org.gradle.api.DefaultTask>
        get() = named<org.gradle.api.DefaultTask>("build")
    


    /**
     * Provides the existing [buildNeeded][org.gradle.api.DefaultTask] task.
     */
    val TaskContainer.`buildNeeded`: TaskProvider<org.gradle.api.DefaultTask>
        get() = named<org.gradle.api.DefaultTask>("buildNeeded")
    


    /**
     * Provides the existing [buildDependents][org.gradle.api.DefaultTask] task.
     */
    val TaskContainer.`buildDependents`: TaskProvider<org.gradle.api.DefaultTask>
        get() = named<org.gradle.api.DefaultTask>("buildDependents")
    


    /**
     * Provides the existing [processResources][org.gradle.language.jvm.tasks.ProcessResources] task.
     */
    val TaskContainer.`processResources`: TaskProvider<org.gradle.language.jvm.tasks.ProcessResources>
        get() = named<org.gradle.language.jvm.tasks.ProcessResources>("processResources")
    


    /**
     * Provides the existing [processTestResources][org.gradle.language.jvm.tasks.ProcessResources] task.
     */
    val TaskContainer.`processTestResources`: TaskProvider<org.gradle.language.jvm.tasks.ProcessResources>
        get() = named<org.gradle.language.jvm.tasks.ProcessResources>("processTestResources")
    


    /**
     * Provides the existing [testClasses][org.gradle.api.DefaultTask] task.
     */
    val TaskContainer.`testClasses`: TaskProvider<org.gradle.api.DefaultTask>
        get() = named<org.gradle.api.DefaultTask>("testClasses")
    


    /**
     * Provides the existing [test][org.gradle.api.tasks.testing.Test] task.
     */
    val TaskContainer.`test`: TaskProvider<org.gradle.api.tasks.testing.Test>
        get() = named<org.gradle.api.tasks.testing.Test>("test")
    


    /**
     * Provides the existing [javadoc][org.gradle.api.tasks.javadoc.Javadoc] task.
     */
    val TaskContainer.`javadoc`: TaskProvider<org.gradle.api.tasks.javadoc.Javadoc>
        get() = named<org.gradle.api.tasks.javadoc.Javadoc>("javadoc")
    


    /**
     * Provides the existing [pluginUnderTestMetadata][org.gradle.plugin.devel.tasks.PluginUnderTestMetadata] task.
     */
    val TaskContainer.`pluginUnderTestMetadata`: TaskProvider<org.gradle.plugin.devel.tasks.PluginUnderTestMetadata>
        get() = named<org.gradle.plugin.devel.tasks.PluginUnderTestMetadata>("pluginUnderTestMetadata")
    


    /**
     * Provides the existing [pluginDescriptors][org.gradle.plugin.devel.tasks.GeneratePluginDescriptors] task.
     */
    val TaskContainer.`pluginDescriptors`: TaskProvider<org.gradle.plugin.devel.tasks.GeneratePluginDescriptors>
        get() = named<org.gradle.plugin.devel.tasks.GeneratePluginDescriptors>("pluginDescriptors")
    


    /**
     * Provides the existing [nagAboutValidateTaskProperties][org.gradle.api.DefaultTask] task.
     */
    val TaskContainer.`nagAboutValidateTaskProperties`: TaskProvider<org.gradle.api.DefaultTask>
        get() = named<org.gradle.api.DefaultTask>("nagAboutValidateTaskProperties")
    


    /**
     * Provides the existing [validatePlugins][org.gradle.plugin.devel.tasks.ValidatePlugins] task.
     */
    val TaskContainer.`validatePlugins`: TaskProvider<org.gradle.plugin.devel.tasks.ValidatePlugins>
        get() = named<org.gradle.plugin.devel.tasks.ValidatePlugins>("validatePlugins")
    


    /**
     * Provides the existing [validateTaskProperties][org.gradle.plugin.devel.tasks.ValidateTaskProperties] task.
     */
    val TaskContainer.`validateTaskProperties`: TaskProvider<org.gradle.plugin.devel.tasks.ValidateTaskProperties>
        get() = named<org.gradle.plugin.devel.tasks.ValidateTaskProperties>("validateTaskProperties")
    


    /**
     * Provides the existing [mainClasses][org.gradle.api.DefaultTask] task.
     */
    val TaskContainer.`mainClasses`: TaskProvider<org.gradle.api.DefaultTask>
        get() = named<org.gradle.api.DefaultTask>("mainClasses")
    


    /**
     * Provides the existing [inspectClassesForKotlinIC][org.gradle.api.DefaultTask] task.
     */
    val TaskContainer.`inspectClassesForKotlinIC`: TaskProvider<org.gradle.api.DefaultTask>
        get() = named<org.gradle.api.DefaultTask>("inspectClassesForKotlinIC")
    


    /**
     * Provides the existing [extractPrecompiledScriptPluginPlugins][org.gradle.kotlin.dsl.provider.plugins.precompiled.tasks.ExtractPrecompiledScriptPluginPlugins] task.
     */
    val TaskContainer.`extractPrecompiledScriptPluginPlugins`: TaskProvider<org.gradle.kotlin.dsl.provider.plugins.precompiled.tasks.ExtractPrecompiledScriptPluginPlugins>
        get() = named<org.gradle.kotlin.dsl.provider.plugins.precompiled.tasks.ExtractPrecompiledScriptPluginPlugins>("extractPrecompiledScriptPluginPlugins")
    


    /**
     * Provides the existing [generateExternalPluginSpecBuilders][org.gradle.kotlin.dsl.provider.plugins.precompiled.tasks.GenerateExternalPluginSpecBuilders] task.
     */
    val TaskContainer.`generateExternalPluginSpecBuilders`: TaskProvider<org.gradle.kotlin.dsl.provider.plugins.precompiled.tasks.GenerateExternalPluginSpecBuilders>
        get() = named<org.gradle.kotlin.dsl.provider.plugins.precompiled.tasks.GenerateExternalPluginSpecBuilders>("generateExternalPluginSpecBuilders")
    


    /**
     * Provides the existing [compilePluginsBlocks][org.gradle.kotlin.dsl.provider.plugins.precompiled.tasks.CompilePrecompiledScriptPluginPlugins] task.
     */
    val TaskContainer.`compilePluginsBlocks`: TaskProvider<org.gradle.kotlin.dsl.provider.plugins.precompiled.tasks.CompilePrecompiledScriptPluginPlugins>
        get() = named<org.gradle.kotlin.dsl.provider.plugins.precompiled.tasks.CompilePrecompiledScriptPluginPlugins>("compilePluginsBlocks")
    


    /**
     * Provides the existing [generatePrecompiledScriptPluginAccessors][org.gradle.kotlin.dsl.provider.plugins.precompiled.tasks.GeneratePrecompiledScriptPluginAccessors] task.
     */
    val TaskContainer.`generatePrecompiledScriptPluginAccessors`: TaskProvider<org.gradle.kotlin.dsl.provider.plugins.precompiled.tasks.GeneratePrecompiledScriptPluginAccessors>
        get() = named<org.gradle.kotlin.dsl.provider.plugins.precompiled.tasks.GeneratePrecompiledScriptPluginAccessors>("generatePrecompiledScriptPluginAccessors")
    


    /**
     * Provides the existing [configurePrecompiledScriptDependenciesResolver][org.gradle.kotlin.dsl.provider.plugins.precompiled.tasks.ConfigurePrecompiledScriptDependenciesResolver] task.
     */
    val TaskContainer.`configurePrecompiledScriptDependenciesResolver`: TaskProvider<org.gradle.kotlin.dsl.provider.plugins.precompiled.tasks.ConfigurePrecompiledScriptDependenciesResolver>
        get() = named<org.gradle.kotlin.dsl.provider.plugins.precompiled.tasks.ConfigurePrecompiledScriptDependenciesResolver>("configurePrecompiledScriptDependenciesResolver")
    


    /**
     * Provides the existing [generateScriptPluginAdapters][org.gradle.kotlin.dsl.provider.plugins.precompiled.tasks.GenerateScriptPluginAdapters] task.
     */
    val TaskContainer.`generateScriptPluginAdapters`: TaskProvider<org.gradle.kotlin.dsl.provider.plugins.precompiled.tasks.GenerateScriptPluginAdapters>
        get() = named<org.gradle.kotlin.dsl.provider.plugins.precompiled.tasks.GenerateScriptPluginAdapters>("generateScriptPluginAdapters")
    


    /**
     * Provides the existing [main][org.gradle.api.tasks.SourceSet] element.
     */
    val org.gradle.api.tasks.SourceSetContainer.`main`: NamedDomainObjectProvider<org.gradle.api.tasks.SourceSet>
        get() = named<org.gradle.api.tasks.SourceSet>("main")
    


    /**
     * Provides the existing [test][org.gradle.api.tasks.SourceSet] element.
     */
    val org.gradle.api.tasks.SourceSetContainer.`test`: NamedDomainObjectProvider<org.gradle.api.tasks.SourceSet>
        get() = named<org.gradle.api.tasks.SourceSet>("test")
    


    /**
     * Provides the existing [main][org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet>.`main`: NamedDomainObjectProvider<org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet>
        get() = named<org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet>("main")
    


    /**
     * Provides the existing [test][org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet>.`test`: NamedDomainObjectProvider<org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet>
        get() = named<org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet>("test")
    


    /**
     * Provides the existing [-api][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`-api`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("-api")
    


    /**
     * Provides the existing [-runtime][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`-runtime`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("-runtime")
    


    /**
     * Provides the existing [annotationProcessor][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`annotationProcessor`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("annotationProcessor")
    


    /**
     * Provides the existing [api][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`api`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("api")
    


    /**
     * Provides the existing [apiDependenciesMetadata][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`apiDependenciesMetadata`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("apiDependenciesMetadata")
    


    /**
     * Provides the existing [apiElements][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`apiElements`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("apiElements")
    


    /**
     * Provides the existing [archives][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`archives`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("archives")
    


    /**
     * Provides the existing [compile][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`compile`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("compile")
    


    /**
     * Provides the existing [compileClasspath][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`compileClasspath`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("compileClasspath")
    


    /**
     * Provides the existing [compileOnly][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`compileOnly`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("compileOnly")
    


    /**
     * Provides the existing [compileOnlyDependenciesMetadata][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`compileOnlyDependenciesMetadata`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("compileOnlyDependenciesMetadata")
    


    /**
     * Provides the existing [default][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`default`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("default")
    


    /**
     * Provides the existing [embeddedKotlin][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`embeddedKotlin`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("embeddedKotlin")
    


    /**
     * Provides the existing [implementation][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`implementation`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("implementation")
    


    /**
     * Provides the existing [implementationDependenciesMetadata][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`implementationDependenciesMetadata`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("implementationDependenciesMetadata")
    


    /**
     * Provides the existing [kotlinCompilerClasspath][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`kotlinCompilerClasspath`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("kotlinCompilerClasspath")
    


    /**
     * Provides the existing [kotlinCompilerPluginClasspath][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`kotlinCompilerPluginClasspath`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("kotlinCompilerPluginClasspath")
    


    /**
     * Provides the existing [kotlinNativeCompilerPluginClasspath][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`kotlinNativeCompilerPluginClasspath`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("kotlinNativeCompilerPluginClasspath")
    


    /**
     * Provides the existing [kotlinScriptDef][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`kotlinScriptDef`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("kotlinScriptDef")
    


    /**
     * Provides the existing [kotlinScriptDefExtensions][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`kotlinScriptDefExtensions`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("kotlinScriptDefExtensions")
    


    /**
     * Provides the existing [runtime][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`runtime`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("runtime")
    


    /**
     * Provides the existing [runtimeClasspath][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`runtimeClasspath`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("runtimeClasspath")
    


    /**
     * Provides the existing [runtimeElements][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`runtimeElements`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("runtimeElements")
    


    /**
     * Provides the existing [runtimeOnly][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`runtimeOnly`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("runtimeOnly")
    


    /**
     * Provides the existing [runtimeOnlyDependenciesMetadata][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`runtimeOnlyDependenciesMetadata`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("runtimeOnlyDependenciesMetadata")
    


    /**
     * Provides the existing [sourceArtifacts][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`sourceArtifacts`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("sourceArtifacts")
    


    /**
     * Provides the existing [testAnnotationProcessor][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`testAnnotationProcessor`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("testAnnotationProcessor")
    


    /**
     * Provides the existing [testApi][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`testApi`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("testApi")
    


    /**
     * Provides the existing [testApiDependenciesMetadata][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`testApiDependenciesMetadata`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("testApiDependenciesMetadata")
    


    /**
     * Provides the existing [testCompile][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`testCompile`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("testCompile")
    


    /**
     * Provides the existing [testCompileClasspath][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`testCompileClasspath`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("testCompileClasspath")
    


    /**
     * Provides the existing [testCompileOnly][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`testCompileOnly`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("testCompileOnly")
    


    /**
     * Provides the existing [testCompileOnlyDependenciesMetadata][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`testCompileOnlyDependenciesMetadata`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("testCompileOnlyDependenciesMetadata")
    


    /**
     * Provides the existing [testImplementation][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`testImplementation`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("testImplementation")
    


    /**
     * Provides the existing [testImplementationDependenciesMetadata][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`testImplementationDependenciesMetadata`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("testImplementationDependenciesMetadata")
    


    /**
     * Provides the existing [testKotlinScriptDef][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`testKotlinScriptDef`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("testKotlinScriptDef")
    


    /**
     * Provides the existing [testKotlinScriptDefExtensions][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`testKotlinScriptDefExtensions`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("testKotlinScriptDefExtensions")
    


    /**
     * Provides the existing [testRuntime][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`testRuntime`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("testRuntime")
    


    /**
     * Provides the existing [testRuntimeClasspath][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`testRuntimeClasspath`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("testRuntimeClasspath")
    


    /**
     * Provides the existing [testRuntimeOnly][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`testRuntimeOnly`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("testRuntimeOnly")
    


    /**
     * Provides the existing [testRuntimeOnlyDependenciesMetadata][org.gradle.api.artifacts.Configuration] element.
     */
    val org.gradle.api.NamedDomainObjectContainer<org.gradle.api.artifacts.Configuration>.`testRuntimeOnlyDependenciesMetadata`: NamedDomainObjectProvider<org.gradle.api.artifacts.Configuration>
        get() = named<org.gradle.api.artifacts.Configuration>("testRuntimeOnlyDependenciesMetadata")
    


    /**
     * Adds a dependency to the '-api' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`-api`(dependencyNotation: Any): Dependency? =
        add("-api", dependencyNotation)


    /**
     * Adds a dependency to the '-api' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`-api`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "-api", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the '-api' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`-api`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "-api", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the '-api' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`-api`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("-api", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the '-api' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`-api`(constraintNotation: Any): DependencyConstraint? =
        add("-api", constraintNotation)


    /**
     * Adds a dependency constraint to the '-api' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`-api`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("-api", constraintNotation, block)


    /**
     * Adds an artifact to the '-api' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`-api`(artifactNotation: Any): PublishArtifact =
        add("-api", artifactNotation)


    /**
     * Adds an artifact to the '-api' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`-api`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("-api", artifactNotation, configureAction)


    /**
     * Adds a dependency to the '-runtime' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`-runtime`(dependencyNotation: Any): Dependency? =
        add("-runtime", dependencyNotation)


    /**
     * Adds a dependency to the '-runtime' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`-runtime`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "-runtime", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the '-runtime' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`-runtime`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "-runtime", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the '-runtime' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`-runtime`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("-runtime", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the '-runtime' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`-runtime`(constraintNotation: Any): DependencyConstraint? =
        add("-runtime", constraintNotation)


    /**
     * Adds a dependency constraint to the '-runtime' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`-runtime`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("-runtime", constraintNotation, block)


    /**
     * Adds an artifact to the '-runtime' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`-runtime`(artifactNotation: Any): PublishArtifact =
        add("-runtime", artifactNotation)


    /**
     * Adds an artifact to the '-runtime' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`-runtime`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("-runtime", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'annotationProcessor' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`annotationProcessor`(dependencyNotation: Any): Dependency? =
        add("annotationProcessor", dependencyNotation)


    /**
     * Adds a dependency to the 'annotationProcessor' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`annotationProcessor`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "annotationProcessor", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'annotationProcessor' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`annotationProcessor`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "annotationProcessor", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'annotationProcessor' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`annotationProcessor`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("annotationProcessor", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'annotationProcessor' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`annotationProcessor`(constraintNotation: Any): DependencyConstraint? =
        add("annotationProcessor", constraintNotation)


    /**
     * Adds a dependency constraint to the 'annotationProcessor' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`annotationProcessor`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("annotationProcessor", constraintNotation, block)


    /**
     * Adds an artifact to the 'annotationProcessor' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`annotationProcessor`(artifactNotation: Any): PublishArtifact =
        add("annotationProcessor", artifactNotation)


    /**
     * Adds an artifact to the 'annotationProcessor' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`annotationProcessor`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("annotationProcessor", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'api' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`api`(dependencyNotation: Any): Dependency? =
        add("api", dependencyNotation)


    /**
     * Adds a dependency to the 'api' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`api`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "api", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'api' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`api`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "api", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'api' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`api`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("api", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'api' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`api`(constraintNotation: Any): DependencyConstraint? =
        add("api", constraintNotation)


    /**
     * Adds a dependency constraint to the 'api' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`api`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("api", constraintNotation, block)


    /**
     * Adds an artifact to the 'api' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`api`(artifactNotation: Any): PublishArtifact =
        add("api", artifactNotation)


    /**
     * Adds an artifact to the 'api' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`api`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("api", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'apiDependenciesMetadata' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`apiDependenciesMetadata`(dependencyNotation: Any): Dependency? =
        add("apiDependenciesMetadata", dependencyNotation)


    /**
     * Adds a dependency to the 'apiDependenciesMetadata' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`apiDependenciesMetadata`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "apiDependenciesMetadata", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'apiDependenciesMetadata' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`apiDependenciesMetadata`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "apiDependenciesMetadata", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'apiDependenciesMetadata' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`apiDependenciesMetadata`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("apiDependenciesMetadata", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'apiDependenciesMetadata' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`apiDependenciesMetadata`(constraintNotation: Any): DependencyConstraint? =
        add("apiDependenciesMetadata", constraintNotation)


    /**
     * Adds a dependency constraint to the 'apiDependenciesMetadata' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`apiDependenciesMetadata`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("apiDependenciesMetadata", constraintNotation, block)


    /**
     * Adds an artifact to the 'apiDependenciesMetadata' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`apiDependenciesMetadata`(artifactNotation: Any): PublishArtifact =
        add("apiDependenciesMetadata", artifactNotation)


    /**
     * Adds an artifact to the 'apiDependenciesMetadata' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`apiDependenciesMetadata`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("apiDependenciesMetadata", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'apiElements' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The apiElements configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' configuration instead.")
    fun DependencyHandler.`apiElements`(dependencyNotation: Any): Dependency? =
        add("apiElements", dependencyNotation)


    /**
     * Adds a dependency to the 'apiElements' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The apiElements configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' configuration instead.")
    fun DependencyHandler.`apiElements`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "apiElements", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'apiElements' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The apiElements configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' configuration instead.")
    fun DependencyHandler.`apiElements`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "apiElements", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'apiElements' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The apiElements configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' configuration instead.")
    fun <T : ModuleDependency> DependencyHandler.`apiElements`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("apiElements", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'apiElements' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    @Deprecated(message = "The apiElements configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' configuration instead.")
    fun DependencyConstraintHandler.`apiElements`(constraintNotation: Any): DependencyConstraint? =
        add("apiElements", constraintNotation)


    /**
     * Adds a dependency constraint to the 'apiElements' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    @Deprecated(message = "The apiElements configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' configuration instead.")
    fun DependencyConstraintHandler.`apiElements`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("apiElements", constraintNotation, block)


    /**
     * Adds an artifact to the 'apiElements' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`apiElements`(artifactNotation: Any): PublishArtifact =
        add("apiElements", artifactNotation)


    /**
     * Adds an artifact to the 'apiElements' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`apiElements`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("apiElements", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'archives' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`archives`(dependencyNotation: Any): Dependency? =
        add("archives", dependencyNotation)


    /**
     * Adds a dependency to the 'archives' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`archives`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "archives", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'archives' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`archives`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "archives", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'archives' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`archives`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("archives", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'archives' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`archives`(constraintNotation: Any): DependencyConstraint? =
        add("archives", constraintNotation)


    /**
     * Adds a dependency constraint to the 'archives' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`archives`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("archives", constraintNotation, block)


    /**
     * Adds an artifact to the 'archives' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`archives`(artifactNotation: Any): PublishArtifact =
        add("archives", artifactNotation)


    /**
     * Adds an artifact to the 'archives' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`archives`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("archives", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'compile' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The compile configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' configuration instead.")
    fun DependencyHandler.`compile`(dependencyNotation: Any): Dependency? =
        add("compile", dependencyNotation)


    /**
     * Adds a dependency to the 'compile' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The compile configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' configuration instead.")
    fun DependencyHandler.`compile`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "compile", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'compile' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The compile configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' configuration instead.")
    fun DependencyHandler.`compile`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "compile", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'compile' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The compile configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' configuration instead.")
    fun <T : ModuleDependency> DependencyHandler.`compile`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("compile", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'compile' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    @Deprecated(message = "The compile configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' configuration instead.")
    fun DependencyConstraintHandler.`compile`(constraintNotation: Any): DependencyConstraint? =
        add("compile", constraintNotation)


    /**
     * Adds a dependency constraint to the 'compile' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    @Deprecated(message = "The compile configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' configuration instead.")
    fun DependencyConstraintHandler.`compile`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("compile", constraintNotation, block)


    /**
     * Adds an artifact to the 'compile' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`compile`(artifactNotation: Any): PublishArtifact =
        add("compile", artifactNotation)


    /**
     * Adds an artifact to the 'compile' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`compile`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("compile", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'compileClasspath' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The compileClasspath configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' configuration instead.")
    fun DependencyHandler.`compileClasspath`(dependencyNotation: Any): Dependency? =
        add("compileClasspath", dependencyNotation)


    /**
     * Adds a dependency to the 'compileClasspath' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The compileClasspath configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' configuration instead.")
    fun DependencyHandler.`compileClasspath`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "compileClasspath", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'compileClasspath' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The compileClasspath configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' configuration instead.")
    fun DependencyHandler.`compileClasspath`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "compileClasspath", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'compileClasspath' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The compileClasspath configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' configuration instead.")
    fun <T : ModuleDependency> DependencyHandler.`compileClasspath`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("compileClasspath", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'compileClasspath' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    @Deprecated(message = "The compileClasspath configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' configuration instead.")
    fun DependencyConstraintHandler.`compileClasspath`(constraintNotation: Any): DependencyConstraint? =
        add("compileClasspath", constraintNotation)


    /**
     * Adds a dependency constraint to the 'compileClasspath' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    @Deprecated(message = "The compileClasspath configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' configuration instead.")
    fun DependencyConstraintHandler.`compileClasspath`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("compileClasspath", constraintNotation, block)


    /**
     * Adds an artifact to the 'compileClasspath' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`compileClasspath`(artifactNotation: Any): PublishArtifact =
        add("compileClasspath", artifactNotation)


    /**
     * Adds an artifact to the 'compileClasspath' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`compileClasspath`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("compileClasspath", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'compileOnly' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`compileOnly`(dependencyNotation: Any): Dependency? =
        add("compileOnly", dependencyNotation)


    /**
     * Adds a dependency to the 'compileOnly' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`compileOnly`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "compileOnly", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'compileOnly' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`compileOnly`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "compileOnly", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'compileOnly' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`compileOnly`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("compileOnly", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'compileOnly' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`compileOnly`(constraintNotation: Any): DependencyConstraint? =
        add("compileOnly", constraintNotation)


    /**
     * Adds a dependency constraint to the 'compileOnly' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`compileOnly`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("compileOnly", constraintNotation, block)


    /**
     * Adds an artifact to the 'compileOnly' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`compileOnly`(artifactNotation: Any): PublishArtifact =
        add("compileOnly", artifactNotation)


    /**
     * Adds an artifact to the 'compileOnly' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`compileOnly`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("compileOnly", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'compileOnlyDependenciesMetadata' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`compileOnlyDependenciesMetadata`(dependencyNotation: Any): Dependency? =
        add("compileOnlyDependenciesMetadata", dependencyNotation)


    /**
     * Adds a dependency to the 'compileOnlyDependenciesMetadata' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`compileOnlyDependenciesMetadata`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "compileOnlyDependenciesMetadata", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'compileOnlyDependenciesMetadata' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`compileOnlyDependenciesMetadata`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "compileOnlyDependenciesMetadata", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'compileOnlyDependenciesMetadata' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`compileOnlyDependenciesMetadata`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("compileOnlyDependenciesMetadata", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'compileOnlyDependenciesMetadata' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`compileOnlyDependenciesMetadata`(constraintNotation: Any): DependencyConstraint? =
        add("compileOnlyDependenciesMetadata", constraintNotation)


    /**
     * Adds a dependency constraint to the 'compileOnlyDependenciesMetadata' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`compileOnlyDependenciesMetadata`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("compileOnlyDependenciesMetadata", constraintNotation, block)


    /**
     * Adds an artifact to the 'compileOnlyDependenciesMetadata' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`compileOnlyDependenciesMetadata`(artifactNotation: Any): PublishArtifact =
        add("compileOnlyDependenciesMetadata", artifactNotation)


    /**
     * Adds an artifact to the 'compileOnlyDependenciesMetadata' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`compileOnlyDependenciesMetadata`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("compileOnlyDependenciesMetadata", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'default' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`default`(dependencyNotation: Any): Dependency? =
        add("default", dependencyNotation)


    /**
     * Adds a dependency to the 'default' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`default`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "default", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'default' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`default`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "default", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'default' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`default`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("default", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'default' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`default`(constraintNotation: Any): DependencyConstraint? =
        add("default", constraintNotation)


    /**
     * Adds a dependency constraint to the 'default' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`default`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("default", constraintNotation, block)


    /**
     * Adds an artifact to the 'default' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`default`(artifactNotation: Any): PublishArtifact =
        add("default", artifactNotation)


    /**
     * Adds an artifact to the 'default' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`default`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("default", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'embeddedKotlin' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`embeddedKotlin`(dependencyNotation: Any): Dependency? =
        add("embeddedKotlin", dependencyNotation)


    /**
     * Adds a dependency to the 'embeddedKotlin' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`embeddedKotlin`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "embeddedKotlin", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'embeddedKotlin' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`embeddedKotlin`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "embeddedKotlin", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'embeddedKotlin' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`embeddedKotlin`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("embeddedKotlin", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'embeddedKotlin' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`embeddedKotlin`(constraintNotation: Any): DependencyConstraint? =
        add("embeddedKotlin", constraintNotation)


    /**
     * Adds a dependency constraint to the 'embeddedKotlin' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`embeddedKotlin`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("embeddedKotlin", constraintNotation, block)


    /**
     * Adds an artifact to the 'embeddedKotlin' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`embeddedKotlin`(artifactNotation: Any): PublishArtifact =
        add("embeddedKotlin", artifactNotation)


    /**
     * Adds an artifact to the 'embeddedKotlin' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`embeddedKotlin`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("embeddedKotlin", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'implementation' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`implementation`(dependencyNotation: Any): Dependency? =
        add("implementation", dependencyNotation)


    /**
     * Adds a dependency to the 'implementation' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`implementation`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "implementation", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'implementation' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`implementation`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "implementation", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'implementation' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`implementation`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("implementation", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'implementation' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`implementation`(constraintNotation: Any): DependencyConstraint? =
        add("implementation", constraintNotation)


    /**
     * Adds a dependency constraint to the 'implementation' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`implementation`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("implementation", constraintNotation, block)


    /**
     * Adds an artifact to the 'implementation' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`implementation`(artifactNotation: Any): PublishArtifact =
        add("implementation", artifactNotation)


    /**
     * Adds an artifact to the 'implementation' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`implementation`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("implementation", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'implementationDependenciesMetadata' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`implementationDependenciesMetadata`(dependencyNotation: Any): Dependency? =
        add("implementationDependenciesMetadata", dependencyNotation)


    /**
     * Adds a dependency to the 'implementationDependenciesMetadata' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`implementationDependenciesMetadata`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "implementationDependenciesMetadata", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'implementationDependenciesMetadata' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`implementationDependenciesMetadata`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "implementationDependenciesMetadata", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'implementationDependenciesMetadata' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`implementationDependenciesMetadata`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("implementationDependenciesMetadata", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'implementationDependenciesMetadata' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`implementationDependenciesMetadata`(constraintNotation: Any): DependencyConstraint? =
        add("implementationDependenciesMetadata", constraintNotation)


    /**
     * Adds a dependency constraint to the 'implementationDependenciesMetadata' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`implementationDependenciesMetadata`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("implementationDependenciesMetadata", constraintNotation, block)


    /**
     * Adds an artifact to the 'implementationDependenciesMetadata' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`implementationDependenciesMetadata`(artifactNotation: Any): PublishArtifact =
        add("implementationDependenciesMetadata", artifactNotation)


    /**
     * Adds an artifact to the 'implementationDependenciesMetadata' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`implementationDependenciesMetadata`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("implementationDependenciesMetadata", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'kotlinCompilerClasspath' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`kotlinCompilerClasspath`(dependencyNotation: Any): Dependency? =
        add("kotlinCompilerClasspath", dependencyNotation)


    /**
     * Adds a dependency to the 'kotlinCompilerClasspath' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`kotlinCompilerClasspath`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "kotlinCompilerClasspath", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'kotlinCompilerClasspath' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`kotlinCompilerClasspath`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "kotlinCompilerClasspath", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'kotlinCompilerClasspath' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`kotlinCompilerClasspath`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("kotlinCompilerClasspath", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'kotlinCompilerClasspath' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`kotlinCompilerClasspath`(constraintNotation: Any): DependencyConstraint? =
        add("kotlinCompilerClasspath", constraintNotation)


    /**
     * Adds a dependency constraint to the 'kotlinCompilerClasspath' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`kotlinCompilerClasspath`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("kotlinCompilerClasspath", constraintNotation, block)


    /**
     * Adds an artifact to the 'kotlinCompilerClasspath' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`kotlinCompilerClasspath`(artifactNotation: Any): PublishArtifact =
        add("kotlinCompilerClasspath", artifactNotation)


    /**
     * Adds an artifact to the 'kotlinCompilerClasspath' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`kotlinCompilerClasspath`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("kotlinCompilerClasspath", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'kotlinCompilerPluginClasspath' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`kotlinCompilerPluginClasspath`(dependencyNotation: Any): Dependency? =
        add("kotlinCompilerPluginClasspath", dependencyNotation)


    /**
     * Adds a dependency to the 'kotlinCompilerPluginClasspath' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`kotlinCompilerPluginClasspath`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "kotlinCompilerPluginClasspath", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'kotlinCompilerPluginClasspath' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`kotlinCompilerPluginClasspath`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "kotlinCompilerPluginClasspath", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'kotlinCompilerPluginClasspath' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`kotlinCompilerPluginClasspath`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("kotlinCompilerPluginClasspath", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'kotlinCompilerPluginClasspath' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`kotlinCompilerPluginClasspath`(constraintNotation: Any): DependencyConstraint? =
        add("kotlinCompilerPluginClasspath", constraintNotation)


    /**
     * Adds a dependency constraint to the 'kotlinCompilerPluginClasspath' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`kotlinCompilerPluginClasspath`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("kotlinCompilerPluginClasspath", constraintNotation, block)


    /**
     * Adds an artifact to the 'kotlinCompilerPluginClasspath' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`kotlinCompilerPluginClasspath`(artifactNotation: Any): PublishArtifact =
        add("kotlinCompilerPluginClasspath", artifactNotation)


    /**
     * Adds an artifact to the 'kotlinCompilerPluginClasspath' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`kotlinCompilerPluginClasspath`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("kotlinCompilerPluginClasspath", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'kotlinNativeCompilerPluginClasspath' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`kotlinNativeCompilerPluginClasspath`(dependencyNotation: Any): Dependency? =
        add("kotlinNativeCompilerPluginClasspath", dependencyNotation)


    /**
     * Adds a dependency to the 'kotlinNativeCompilerPluginClasspath' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`kotlinNativeCompilerPluginClasspath`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "kotlinNativeCompilerPluginClasspath", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'kotlinNativeCompilerPluginClasspath' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`kotlinNativeCompilerPluginClasspath`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "kotlinNativeCompilerPluginClasspath", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'kotlinNativeCompilerPluginClasspath' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`kotlinNativeCompilerPluginClasspath`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("kotlinNativeCompilerPluginClasspath", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'kotlinNativeCompilerPluginClasspath' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`kotlinNativeCompilerPluginClasspath`(constraintNotation: Any): DependencyConstraint? =
        add("kotlinNativeCompilerPluginClasspath", constraintNotation)


    /**
     * Adds a dependency constraint to the 'kotlinNativeCompilerPluginClasspath' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`kotlinNativeCompilerPluginClasspath`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("kotlinNativeCompilerPluginClasspath", constraintNotation, block)


    /**
     * Adds an artifact to the 'kotlinNativeCompilerPluginClasspath' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`kotlinNativeCompilerPluginClasspath`(artifactNotation: Any): PublishArtifact =
        add("kotlinNativeCompilerPluginClasspath", artifactNotation)


    /**
     * Adds an artifact to the 'kotlinNativeCompilerPluginClasspath' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`kotlinNativeCompilerPluginClasspath`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("kotlinNativeCompilerPluginClasspath", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'kotlinScriptDef' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`kotlinScriptDef`(dependencyNotation: Any): Dependency? =
        add("kotlinScriptDef", dependencyNotation)


    /**
     * Adds a dependency to the 'kotlinScriptDef' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`kotlinScriptDef`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "kotlinScriptDef", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'kotlinScriptDef' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`kotlinScriptDef`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "kotlinScriptDef", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'kotlinScriptDef' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`kotlinScriptDef`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("kotlinScriptDef", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'kotlinScriptDef' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`kotlinScriptDef`(constraintNotation: Any): DependencyConstraint? =
        add("kotlinScriptDef", constraintNotation)


    /**
     * Adds a dependency constraint to the 'kotlinScriptDef' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`kotlinScriptDef`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("kotlinScriptDef", constraintNotation, block)


    /**
     * Adds an artifact to the 'kotlinScriptDef' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`kotlinScriptDef`(artifactNotation: Any): PublishArtifact =
        add("kotlinScriptDef", artifactNotation)


    /**
     * Adds an artifact to the 'kotlinScriptDef' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`kotlinScriptDef`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("kotlinScriptDef", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'kotlinScriptDefExtensions' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`kotlinScriptDefExtensions`(dependencyNotation: Any): Dependency? =
        add("kotlinScriptDefExtensions", dependencyNotation)


    /**
     * Adds a dependency to the 'kotlinScriptDefExtensions' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`kotlinScriptDefExtensions`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "kotlinScriptDefExtensions", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'kotlinScriptDefExtensions' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`kotlinScriptDefExtensions`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "kotlinScriptDefExtensions", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'kotlinScriptDefExtensions' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`kotlinScriptDefExtensions`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("kotlinScriptDefExtensions", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'kotlinScriptDefExtensions' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`kotlinScriptDefExtensions`(constraintNotation: Any): DependencyConstraint? =
        add("kotlinScriptDefExtensions", constraintNotation)


    /**
     * Adds a dependency constraint to the 'kotlinScriptDefExtensions' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`kotlinScriptDefExtensions`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("kotlinScriptDefExtensions", constraintNotation, block)


    /**
     * Adds an artifact to the 'kotlinScriptDefExtensions' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`kotlinScriptDefExtensions`(artifactNotation: Any): PublishArtifact =
        add("kotlinScriptDefExtensions", artifactNotation)


    /**
     * Adds an artifact to the 'kotlinScriptDefExtensions' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`kotlinScriptDefExtensions`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("kotlinScriptDefExtensions", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'runtime' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The runtime configuration has been deprecated for dependency declaration. Please use the 'runtimeOnly' configuration instead.")
    fun DependencyHandler.`runtime`(dependencyNotation: Any): Dependency? =
        add("runtime", dependencyNotation)


    /**
     * Adds a dependency to the 'runtime' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The runtime configuration has been deprecated for dependency declaration. Please use the 'runtimeOnly' configuration instead.")
    fun DependencyHandler.`runtime`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "runtime", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'runtime' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The runtime configuration has been deprecated for dependency declaration. Please use the 'runtimeOnly' configuration instead.")
    fun DependencyHandler.`runtime`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "runtime", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'runtime' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The runtime configuration has been deprecated for dependency declaration. Please use the 'runtimeOnly' configuration instead.")
    fun <T : ModuleDependency> DependencyHandler.`runtime`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("runtime", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'runtime' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    @Deprecated(message = "The runtime configuration has been deprecated for dependency declaration. Please use the 'runtimeOnly' configuration instead.")
    fun DependencyConstraintHandler.`runtime`(constraintNotation: Any): DependencyConstraint? =
        add("runtime", constraintNotation)


    /**
     * Adds a dependency constraint to the 'runtime' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    @Deprecated(message = "The runtime configuration has been deprecated for dependency declaration. Please use the 'runtimeOnly' configuration instead.")
    fun DependencyConstraintHandler.`runtime`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("runtime", constraintNotation, block)


    /**
     * Adds an artifact to the 'runtime' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`runtime`(artifactNotation: Any): PublishArtifact =
        add("runtime", artifactNotation)


    /**
     * Adds an artifact to the 'runtime' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`runtime`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("runtime", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'runtimeClasspath' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The runtimeClasspath configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' or 'runtimeOnly' configuration instead.")
    fun DependencyHandler.`runtimeClasspath`(dependencyNotation: Any): Dependency? =
        add("runtimeClasspath", dependencyNotation)


    /**
     * Adds a dependency to the 'runtimeClasspath' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The runtimeClasspath configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' or 'runtimeOnly' configuration instead.")
    fun DependencyHandler.`runtimeClasspath`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "runtimeClasspath", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'runtimeClasspath' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The runtimeClasspath configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' or 'runtimeOnly' configuration instead.")
    fun DependencyHandler.`runtimeClasspath`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "runtimeClasspath", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'runtimeClasspath' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The runtimeClasspath configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' or 'runtimeOnly' configuration instead.")
    fun <T : ModuleDependency> DependencyHandler.`runtimeClasspath`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("runtimeClasspath", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'runtimeClasspath' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    @Deprecated(message = "The runtimeClasspath configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' or 'runtimeOnly' configuration instead.")
    fun DependencyConstraintHandler.`runtimeClasspath`(constraintNotation: Any): DependencyConstraint? =
        add("runtimeClasspath", constraintNotation)


    /**
     * Adds a dependency constraint to the 'runtimeClasspath' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    @Deprecated(message = "The runtimeClasspath configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' or 'runtimeOnly' configuration instead.")
    fun DependencyConstraintHandler.`runtimeClasspath`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("runtimeClasspath", constraintNotation, block)


    /**
     * Adds an artifact to the 'runtimeClasspath' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`runtimeClasspath`(artifactNotation: Any): PublishArtifact =
        add("runtimeClasspath", artifactNotation)


    /**
     * Adds an artifact to the 'runtimeClasspath' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`runtimeClasspath`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("runtimeClasspath", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'runtimeElements' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The runtimeElements configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' or 'runtimeOnly' configuration instead.")
    fun DependencyHandler.`runtimeElements`(dependencyNotation: Any): Dependency? =
        add("runtimeElements", dependencyNotation)


    /**
     * Adds a dependency to the 'runtimeElements' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The runtimeElements configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' or 'runtimeOnly' configuration instead.")
    fun DependencyHandler.`runtimeElements`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "runtimeElements", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'runtimeElements' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The runtimeElements configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' or 'runtimeOnly' configuration instead.")
    fun DependencyHandler.`runtimeElements`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "runtimeElements", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'runtimeElements' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The runtimeElements configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' or 'runtimeOnly' configuration instead.")
    fun <T : ModuleDependency> DependencyHandler.`runtimeElements`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("runtimeElements", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'runtimeElements' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    @Deprecated(message = "The runtimeElements configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' or 'runtimeOnly' configuration instead.")
    fun DependencyConstraintHandler.`runtimeElements`(constraintNotation: Any): DependencyConstraint? =
        add("runtimeElements", constraintNotation)


    /**
     * Adds a dependency constraint to the 'runtimeElements' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    @Deprecated(message = "The runtimeElements configuration has been deprecated for dependency declaration. Please use the 'implementation' or 'api' or 'compileOnly' or 'runtimeOnly' configuration instead.")
    fun DependencyConstraintHandler.`runtimeElements`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("runtimeElements", constraintNotation, block)


    /**
     * Adds an artifact to the 'runtimeElements' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`runtimeElements`(artifactNotation: Any): PublishArtifact =
        add("runtimeElements", artifactNotation)


    /**
     * Adds an artifact to the 'runtimeElements' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`runtimeElements`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("runtimeElements", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'runtimeOnly' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`runtimeOnly`(dependencyNotation: Any): Dependency? =
        add("runtimeOnly", dependencyNotation)


    /**
     * Adds a dependency to the 'runtimeOnly' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`runtimeOnly`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "runtimeOnly", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'runtimeOnly' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`runtimeOnly`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "runtimeOnly", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'runtimeOnly' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`runtimeOnly`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("runtimeOnly", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'runtimeOnly' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`runtimeOnly`(constraintNotation: Any): DependencyConstraint? =
        add("runtimeOnly", constraintNotation)


    /**
     * Adds a dependency constraint to the 'runtimeOnly' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`runtimeOnly`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("runtimeOnly", constraintNotation, block)


    /**
     * Adds an artifact to the 'runtimeOnly' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`runtimeOnly`(artifactNotation: Any): PublishArtifact =
        add("runtimeOnly", artifactNotation)


    /**
     * Adds an artifact to the 'runtimeOnly' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`runtimeOnly`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("runtimeOnly", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'runtimeOnlyDependenciesMetadata' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`runtimeOnlyDependenciesMetadata`(dependencyNotation: Any): Dependency? =
        add("runtimeOnlyDependenciesMetadata", dependencyNotation)


    /**
     * Adds a dependency to the 'runtimeOnlyDependenciesMetadata' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`runtimeOnlyDependenciesMetadata`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "runtimeOnlyDependenciesMetadata", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'runtimeOnlyDependenciesMetadata' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`runtimeOnlyDependenciesMetadata`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "runtimeOnlyDependenciesMetadata", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'runtimeOnlyDependenciesMetadata' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`runtimeOnlyDependenciesMetadata`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("runtimeOnlyDependenciesMetadata", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'runtimeOnlyDependenciesMetadata' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`runtimeOnlyDependenciesMetadata`(constraintNotation: Any): DependencyConstraint? =
        add("runtimeOnlyDependenciesMetadata", constraintNotation)


    /**
     * Adds a dependency constraint to the 'runtimeOnlyDependenciesMetadata' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`runtimeOnlyDependenciesMetadata`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("runtimeOnlyDependenciesMetadata", constraintNotation, block)


    /**
     * Adds an artifact to the 'runtimeOnlyDependenciesMetadata' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`runtimeOnlyDependenciesMetadata`(artifactNotation: Any): PublishArtifact =
        add("runtimeOnlyDependenciesMetadata", artifactNotation)


    /**
     * Adds an artifact to the 'runtimeOnlyDependenciesMetadata' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`runtimeOnlyDependenciesMetadata`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("runtimeOnlyDependenciesMetadata", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'sourceArtifacts' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`sourceArtifacts`(dependencyNotation: Any): Dependency? =
        add("sourceArtifacts", dependencyNotation)


    /**
     * Adds a dependency to the 'sourceArtifacts' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`sourceArtifacts`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "sourceArtifacts", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'sourceArtifacts' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`sourceArtifacts`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "sourceArtifacts", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'sourceArtifacts' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`sourceArtifacts`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("sourceArtifacts", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'sourceArtifacts' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`sourceArtifacts`(constraintNotation: Any): DependencyConstraint? =
        add("sourceArtifacts", constraintNotation)


    /**
     * Adds a dependency constraint to the 'sourceArtifacts' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`sourceArtifacts`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("sourceArtifacts", constraintNotation, block)


    /**
     * Adds an artifact to the 'sourceArtifacts' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`sourceArtifacts`(artifactNotation: Any): PublishArtifact =
        add("sourceArtifacts", artifactNotation)


    /**
     * Adds an artifact to the 'sourceArtifacts' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`sourceArtifacts`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("sourceArtifacts", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'testAnnotationProcessor' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testAnnotationProcessor`(dependencyNotation: Any): Dependency? =
        add("testAnnotationProcessor", dependencyNotation)


    /**
     * Adds a dependency to the 'testAnnotationProcessor' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testAnnotationProcessor`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "testAnnotationProcessor", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'testAnnotationProcessor' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testAnnotationProcessor`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "testAnnotationProcessor", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'testAnnotationProcessor' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`testAnnotationProcessor`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("testAnnotationProcessor", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'testAnnotationProcessor' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`testAnnotationProcessor`(constraintNotation: Any): DependencyConstraint? =
        add("testAnnotationProcessor", constraintNotation)


    /**
     * Adds a dependency constraint to the 'testAnnotationProcessor' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`testAnnotationProcessor`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("testAnnotationProcessor", constraintNotation, block)


    /**
     * Adds an artifact to the 'testAnnotationProcessor' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testAnnotationProcessor`(artifactNotation: Any): PublishArtifact =
        add("testAnnotationProcessor", artifactNotation)


    /**
     * Adds an artifact to the 'testAnnotationProcessor' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testAnnotationProcessor`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("testAnnotationProcessor", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'testApi' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testApi`(dependencyNotation: Any): Dependency? =
        add("testApi", dependencyNotation)


    /**
     * Adds a dependency to the 'testApi' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testApi`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "testApi", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'testApi' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testApi`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "testApi", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'testApi' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`testApi`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("testApi", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'testApi' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`testApi`(constraintNotation: Any): DependencyConstraint? =
        add("testApi", constraintNotation)


    /**
     * Adds a dependency constraint to the 'testApi' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`testApi`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("testApi", constraintNotation, block)


    /**
     * Adds an artifact to the 'testApi' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testApi`(artifactNotation: Any): PublishArtifact =
        add("testApi", artifactNotation)


    /**
     * Adds an artifact to the 'testApi' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testApi`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("testApi", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'testApiDependenciesMetadata' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testApiDependenciesMetadata`(dependencyNotation: Any): Dependency? =
        add("testApiDependenciesMetadata", dependencyNotation)


    /**
     * Adds a dependency to the 'testApiDependenciesMetadata' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testApiDependenciesMetadata`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "testApiDependenciesMetadata", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'testApiDependenciesMetadata' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testApiDependenciesMetadata`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "testApiDependenciesMetadata", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'testApiDependenciesMetadata' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`testApiDependenciesMetadata`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("testApiDependenciesMetadata", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'testApiDependenciesMetadata' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`testApiDependenciesMetadata`(constraintNotation: Any): DependencyConstraint? =
        add("testApiDependenciesMetadata", constraintNotation)


    /**
     * Adds a dependency constraint to the 'testApiDependenciesMetadata' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`testApiDependenciesMetadata`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("testApiDependenciesMetadata", constraintNotation, block)


    /**
     * Adds an artifact to the 'testApiDependenciesMetadata' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testApiDependenciesMetadata`(artifactNotation: Any): PublishArtifact =
        add("testApiDependenciesMetadata", artifactNotation)


    /**
     * Adds an artifact to the 'testApiDependenciesMetadata' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testApiDependenciesMetadata`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("testApiDependenciesMetadata", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'testCompile' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The testCompile configuration has been deprecated for dependency declaration. Please use the 'testImplementation' configuration instead.")
    fun DependencyHandler.`testCompile`(dependencyNotation: Any): Dependency? =
        add("testCompile", dependencyNotation)


    /**
     * Adds a dependency to the 'testCompile' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The testCompile configuration has been deprecated for dependency declaration. Please use the 'testImplementation' configuration instead.")
    fun DependencyHandler.`testCompile`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "testCompile", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'testCompile' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The testCompile configuration has been deprecated for dependency declaration. Please use the 'testImplementation' configuration instead.")
    fun DependencyHandler.`testCompile`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "testCompile", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'testCompile' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The testCompile configuration has been deprecated for dependency declaration. Please use the 'testImplementation' configuration instead.")
    fun <T : ModuleDependency> DependencyHandler.`testCompile`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("testCompile", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'testCompile' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    @Deprecated(message = "The testCompile configuration has been deprecated for dependency declaration. Please use the 'testImplementation' configuration instead.")
    fun DependencyConstraintHandler.`testCompile`(constraintNotation: Any): DependencyConstraint? =
        add("testCompile", constraintNotation)


    /**
     * Adds a dependency constraint to the 'testCompile' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    @Deprecated(message = "The testCompile configuration has been deprecated for dependency declaration. Please use the 'testImplementation' configuration instead.")
    fun DependencyConstraintHandler.`testCompile`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("testCompile", constraintNotation, block)


    /**
     * Adds an artifact to the 'testCompile' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testCompile`(artifactNotation: Any): PublishArtifact =
        add("testCompile", artifactNotation)


    /**
     * Adds an artifact to the 'testCompile' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testCompile`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("testCompile", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'testCompileClasspath' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The testCompileClasspath configuration has been deprecated for dependency declaration. Please use the 'testImplementation' or 'testCompileOnly' configuration instead.")
    fun DependencyHandler.`testCompileClasspath`(dependencyNotation: Any): Dependency? =
        add("testCompileClasspath", dependencyNotation)


    /**
     * Adds a dependency to the 'testCompileClasspath' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The testCompileClasspath configuration has been deprecated for dependency declaration. Please use the 'testImplementation' or 'testCompileOnly' configuration instead.")
    fun DependencyHandler.`testCompileClasspath`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "testCompileClasspath", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'testCompileClasspath' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The testCompileClasspath configuration has been deprecated for dependency declaration. Please use the 'testImplementation' or 'testCompileOnly' configuration instead.")
    fun DependencyHandler.`testCompileClasspath`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "testCompileClasspath", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'testCompileClasspath' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The testCompileClasspath configuration has been deprecated for dependency declaration. Please use the 'testImplementation' or 'testCompileOnly' configuration instead.")
    fun <T : ModuleDependency> DependencyHandler.`testCompileClasspath`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("testCompileClasspath", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'testCompileClasspath' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    @Deprecated(message = "The testCompileClasspath configuration has been deprecated for dependency declaration. Please use the 'testImplementation' or 'testCompileOnly' configuration instead.")
    fun DependencyConstraintHandler.`testCompileClasspath`(constraintNotation: Any): DependencyConstraint? =
        add("testCompileClasspath", constraintNotation)


    /**
     * Adds a dependency constraint to the 'testCompileClasspath' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    @Deprecated(message = "The testCompileClasspath configuration has been deprecated for dependency declaration. Please use the 'testImplementation' or 'testCompileOnly' configuration instead.")
    fun DependencyConstraintHandler.`testCompileClasspath`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("testCompileClasspath", constraintNotation, block)


    /**
     * Adds an artifact to the 'testCompileClasspath' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testCompileClasspath`(artifactNotation: Any): PublishArtifact =
        add("testCompileClasspath", artifactNotation)


    /**
     * Adds an artifact to the 'testCompileClasspath' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testCompileClasspath`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("testCompileClasspath", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'testCompileOnly' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testCompileOnly`(dependencyNotation: Any): Dependency? =
        add("testCompileOnly", dependencyNotation)


    /**
     * Adds a dependency to the 'testCompileOnly' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testCompileOnly`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "testCompileOnly", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'testCompileOnly' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testCompileOnly`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "testCompileOnly", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'testCompileOnly' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`testCompileOnly`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("testCompileOnly", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'testCompileOnly' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`testCompileOnly`(constraintNotation: Any): DependencyConstraint? =
        add("testCompileOnly", constraintNotation)


    /**
     * Adds a dependency constraint to the 'testCompileOnly' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`testCompileOnly`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("testCompileOnly", constraintNotation, block)


    /**
     * Adds an artifact to the 'testCompileOnly' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testCompileOnly`(artifactNotation: Any): PublishArtifact =
        add("testCompileOnly", artifactNotation)


    /**
     * Adds an artifact to the 'testCompileOnly' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testCompileOnly`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("testCompileOnly", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'testCompileOnlyDependenciesMetadata' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testCompileOnlyDependenciesMetadata`(dependencyNotation: Any): Dependency? =
        add("testCompileOnlyDependenciesMetadata", dependencyNotation)


    /**
     * Adds a dependency to the 'testCompileOnlyDependenciesMetadata' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testCompileOnlyDependenciesMetadata`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "testCompileOnlyDependenciesMetadata", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'testCompileOnlyDependenciesMetadata' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testCompileOnlyDependenciesMetadata`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "testCompileOnlyDependenciesMetadata", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'testCompileOnlyDependenciesMetadata' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`testCompileOnlyDependenciesMetadata`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("testCompileOnlyDependenciesMetadata", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'testCompileOnlyDependenciesMetadata' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`testCompileOnlyDependenciesMetadata`(constraintNotation: Any): DependencyConstraint? =
        add("testCompileOnlyDependenciesMetadata", constraintNotation)


    /**
     * Adds a dependency constraint to the 'testCompileOnlyDependenciesMetadata' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`testCompileOnlyDependenciesMetadata`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("testCompileOnlyDependenciesMetadata", constraintNotation, block)


    /**
     * Adds an artifact to the 'testCompileOnlyDependenciesMetadata' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testCompileOnlyDependenciesMetadata`(artifactNotation: Any): PublishArtifact =
        add("testCompileOnlyDependenciesMetadata", artifactNotation)


    /**
     * Adds an artifact to the 'testCompileOnlyDependenciesMetadata' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testCompileOnlyDependenciesMetadata`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("testCompileOnlyDependenciesMetadata", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'testImplementation' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testImplementation`(dependencyNotation: Any): Dependency? =
        add("testImplementation", dependencyNotation)


    /**
     * Adds a dependency to the 'testImplementation' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testImplementation`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "testImplementation", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'testImplementation' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testImplementation`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "testImplementation", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'testImplementation' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`testImplementation`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("testImplementation", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'testImplementation' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`testImplementation`(constraintNotation: Any): DependencyConstraint? =
        add("testImplementation", constraintNotation)


    /**
     * Adds a dependency constraint to the 'testImplementation' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`testImplementation`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("testImplementation", constraintNotation, block)


    /**
     * Adds an artifact to the 'testImplementation' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testImplementation`(artifactNotation: Any): PublishArtifact =
        add("testImplementation", artifactNotation)


    /**
     * Adds an artifact to the 'testImplementation' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testImplementation`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("testImplementation", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'testImplementationDependenciesMetadata' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testImplementationDependenciesMetadata`(dependencyNotation: Any): Dependency? =
        add("testImplementationDependenciesMetadata", dependencyNotation)


    /**
     * Adds a dependency to the 'testImplementationDependenciesMetadata' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testImplementationDependenciesMetadata`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "testImplementationDependenciesMetadata", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'testImplementationDependenciesMetadata' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testImplementationDependenciesMetadata`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "testImplementationDependenciesMetadata", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'testImplementationDependenciesMetadata' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`testImplementationDependenciesMetadata`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("testImplementationDependenciesMetadata", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'testImplementationDependenciesMetadata' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`testImplementationDependenciesMetadata`(constraintNotation: Any): DependencyConstraint? =
        add("testImplementationDependenciesMetadata", constraintNotation)


    /**
     * Adds a dependency constraint to the 'testImplementationDependenciesMetadata' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`testImplementationDependenciesMetadata`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("testImplementationDependenciesMetadata", constraintNotation, block)


    /**
     * Adds an artifact to the 'testImplementationDependenciesMetadata' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testImplementationDependenciesMetadata`(artifactNotation: Any): PublishArtifact =
        add("testImplementationDependenciesMetadata", artifactNotation)


    /**
     * Adds an artifact to the 'testImplementationDependenciesMetadata' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testImplementationDependenciesMetadata`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("testImplementationDependenciesMetadata", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'testKotlinScriptDef' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testKotlinScriptDef`(dependencyNotation: Any): Dependency? =
        add("testKotlinScriptDef", dependencyNotation)


    /**
     * Adds a dependency to the 'testKotlinScriptDef' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testKotlinScriptDef`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "testKotlinScriptDef", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'testKotlinScriptDef' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testKotlinScriptDef`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "testKotlinScriptDef", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'testKotlinScriptDef' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`testKotlinScriptDef`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("testKotlinScriptDef", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'testKotlinScriptDef' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`testKotlinScriptDef`(constraintNotation: Any): DependencyConstraint? =
        add("testKotlinScriptDef", constraintNotation)


    /**
     * Adds a dependency constraint to the 'testKotlinScriptDef' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`testKotlinScriptDef`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("testKotlinScriptDef", constraintNotation, block)


    /**
     * Adds an artifact to the 'testKotlinScriptDef' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testKotlinScriptDef`(artifactNotation: Any): PublishArtifact =
        add("testKotlinScriptDef", artifactNotation)


    /**
     * Adds an artifact to the 'testKotlinScriptDef' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testKotlinScriptDef`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("testKotlinScriptDef", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'testKotlinScriptDefExtensions' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testKotlinScriptDefExtensions`(dependencyNotation: Any): Dependency? =
        add("testKotlinScriptDefExtensions", dependencyNotation)


    /**
     * Adds a dependency to the 'testKotlinScriptDefExtensions' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testKotlinScriptDefExtensions`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "testKotlinScriptDefExtensions", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'testKotlinScriptDefExtensions' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testKotlinScriptDefExtensions`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "testKotlinScriptDefExtensions", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'testKotlinScriptDefExtensions' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`testKotlinScriptDefExtensions`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("testKotlinScriptDefExtensions", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'testKotlinScriptDefExtensions' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`testKotlinScriptDefExtensions`(constraintNotation: Any): DependencyConstraint? =
        add("testKotlinScriptDefExtensions", constraintNotation)


    /**
     * Adds a dependency constraint to the 'testKotlinScriptDefExtensions' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`testKotlinScriptDefExtensions`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("testKotlinScriptDefExtensions", constraintNotation, block)


    /**
     * Adds an artifact to the 'testKotlinScriptDefExtensions' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testKotlinScriptDefExtensions`(artifactNotation: Any): PublishArtifact =
        add("testKotlinScriptDefExtensions", artifactNotation)


    /**
     * Adds an artifact to the 'testKotlinScriptDefExtensions' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testKotlinScriptDefExtensions`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("testKotlinScriptDefExtensions", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'testRuntime' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The testRuntime configuration has been deprecated for dependency declaration. Please use the 'testRuntimeOnly' configuration instead.")
    fun DependencyHandler.`testRuntime`(dependencyNotation: Any): Dependency? =
        add("testRuntime", dependencyNotation)


    /**
     * Adds a dependency to the 'testRuntime' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The testRuntime configuration has been deprecated for dependency declaration. Please use the 'testRuntimeOnly' configuration instead.")
    fun DependencyHandler.`testRuntime`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "testRuntime", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'testRuntime' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The testRuntime configuration has been deprecated for dependency declaration. Please use the 'testRuntimeOnly' configuration instead.")
    fun DependencyHandler.`testRuntime`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "testRuntime", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'testRuntime' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The testRuntime configuration has been deprecated for dependency declaration. Please use the 'testRuntimeOnly' configuration instead.")
    fun <T : ModuleDependency> DependencyHandler.`testRuntime`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("testRuntime", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'testRuntime' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    @Deprecated(message = "The testRuntime configuration has been deprecated for dependency declaration. Please use the 'testRuntimeOnly' configuration instead.")
    fun DependencyConstraintHandler.`testRuntime`(constraintNotation: Any): DependencyConstraint? =
        add("testRuntime", constraintNotation)


    /**
     * Adds a dependency constraint to the 'testRuntime' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    @Deprecated(message = "The testRuntime configuration has been deprecated for dependency declaration. Please use the 'testRuntimeOnly' configuration instead.")
    fun DependencyConstraintHandler.`testRuntime`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("testRuntime", constraintNotation, block)


    /**
     * Adds an artifact to the 'testRuntime' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testRuntime`(artifactNotation: Any): PublishArtifact =
        add("testRuntime", artifactNotation)


    /**
     * Adds an artifact to the 'testRuntime' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testRuntime`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("testRuntime", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'testRuntimeClasspath' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The testRuntimeClasspath configuration has been deprecated for dependency declaration. Please use the 'testImplementation' or 'testCompileOnly' or 'testRuntimeOnly' configuration instead.")
    fun DependencyHandler.`testRuntimeClasspath`(dependencyNotation: Any): Dependency? =
        add("testRuntimeClasspath", dependencyNotation)


    /**
     * Adds a dependency to the 'testRuntimeClasspath' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The testRuntimeClasspath configuration has been deprecated for dependency declaration. Please use the 'testImplementation' or 'testCompileOnly' or 'testRuntimeOnly' configuration instead.")
    fun DependencyHandler.`testRuntimeClasspath`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "testRuntimeClasspath", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'testRuntimeClasspath' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The testRuntimeClasspath configuration has been deprecated for dependency declaration. Please use the 'testImplementation' or 'testCompileOnly' or 'testRuntimeOnly' configuration instead.")
    fun DependencyHandler.`testRuntimeClasspath`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "testRuntimeClasspath", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'testRuntimeClasspath' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    @Deprecated(message = "The testRuntimeClasspath configuration has been deprecated for dependency declaration. Please use the 'testImplementation' or 'testCompileOnly' or 'testRuntimeOnly' configuration instead.")
    fun <T : ModuleDependency> DependencyHandler.`testRuntimeClasspath`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("testRuntimeClasspath", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'testRuntimeClasspath' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    @Deprecated(message = "The testRuntimeClasspath configuration has been deprecated for dependency declaration. Please use the 'testImplementation' or 'testCompileOnly' or 'testRuntimeOnly' configuration instead.")
    fun DependencyConstraintHandler.`testRuntimeClasspath`(constraintNotation: Any): DependencyConstraint? =
        add("testRuntimeClasspath", constraintNotation)


    /**
     * Adds a dependency constraint to the 'testRuntimeClasspath' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    @Deprecated(message = "The testRuntimeClasspath configuration has been deprecated for dependency declaration. Please use the 'testImplementation' or 'testCompileOnly' or 'testRuntimeOnly' configuration instead.")
    fun DependencyConstraintHandler.`testRuntimeClasspath`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("testRuntimeClasspath", constraintNotation, block)


    /**
     * Adds an artifact to the 'testRuntimeClasspath' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testRuntimeClasspath`(artifactNotation: Any): PublishArtifact =
        add("testRuntimeClasspath", artifactNotation)


    /**
     * Adds an artifact to the 'testRuntimeClasspath' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testRuntimeClasspath`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("testRuntimeClasspath", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'testRuntimeOnly' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testRuntimeOnly`(dependencyNotation: Any): Dependency? =
        add("testRuntimeOnly", dependencyNotation)


    /**
     * Adds a dependency to the 'testRuntimeOnly' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testRuntimeOnly`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "testRuntimeOnly", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'testRuntimeOnly' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testRuntimeOnly`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "testRuntimeOnly", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'testRuntimeOnly' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`testRuntimeOnly`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("testRuntimeOnly", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'testRuntimeOnly' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`testRuntimeOnly`(constraintNotation: Any): DependencyConstraint? =
        add("testRuntimeOnly", constraintNotation)


    /**
     * Adds a dependency constraint to the 'testRuntimeOnly' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`testRuntimeOnly`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("testRuntimeOnly", constraintNotation, block)


    /**
     * Adds an artifact to the 'testRuntimeOnly' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testRuntimeOnly`(artifactNotation: Any): PublishArtifact =
        add("testRuntimeOnly", artifactNotation)


    /**
     * Adds an artifact to the 'testRuntimeOnly' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testRuntimeOnly`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("testRuntimeOnly", artifactNotation, configureAction)


    /**
     * Adds a dependency to the 'testRuntimeOnlyDependenciesMetadata' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testRuntimeOnlyDependenciesMetadata`(dependencyNotation: Any): Dependency? =
        add("testRuntimeOnlyDependenciesMetadata", dependencyNotation)


    /**
     * Adds a dependency to the 'testRuntimeOnlyDependenciesMetadata' configuration.
     *
     * @param dependencyNotation notation for the dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testRuntimeOnlyDependenciesMetadata`(
        dependencyNotation: String,
        dependencyConfiguration: Action<ExternalModuleDependency>
    ): ExternalModuleDependency = addDependencyTo(
        this, "testRuntimeOnlyDependenciesMetadata", dependencyNotation, dependencyConfiguration
    ) as ExternalModuleDependency


    /**
     * Adds a dependency to the 'testRuntimeOnlyDependenciesMetadata' configuration.
     *
     * @param group the group of the module to be added as a dependency.
     * @param name the name of the module to be added as a dependency.
     * @param version the optional version of the module to be added as a dependency.
     * @param configuration the optional configuration of the module to be added as a dependency.
     * @param classifier the optional classifier of the module artifact to be added as a dependency.
     * @param ext the optional extension of the module artifact to be added as a dependency.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.create]
     * @see [DependencyHandler.add]
     */
    fun DependencyHandler.`testRuntimeOnlyDependenciesMetadata`(
        group: String,
        name: String,
        version: String? = null,
        configuration: String? = null,
        classifier: String? = null,
        ext: String? = null,
        dependencyConfiguration: Action<ExternalModuleDependency>? = null
    ): ExternalModuleDependency = addExternalModuleDependencyTo(
        this, "testRuntimeOnlyDependenciesMetadata", group, name, version, configuration, classifier, ext, dependencyConfiguration
    )


    /**
     * Adds a dependency to the 'testRuntimeOnlyDependenciesMetadata' configuration.
     *
     * @param dependency dependency to be added.
     * @param dependencyConfiguration expression to use to configure the dependency.
     * @return The dependency.
     *
     * @see [DependencyHandler.add]
     */
    fun <T : ModuleDependency> DependencyHandler.`testRuntimeOnlyDependenciesMetadata`(
        dependency: T,
        dependencyConfiguration: T.() -> Unit
    ): T = add("testRuntimeOnlyDependenciesMetadata", dependency, dependencyConfiguration)


    /**
     * Adds a dependency constraint to the 'testRuntimeOnlyDependenciesMetadata' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`testRuntimeOnlyDependenciesMetadata`(constraintNotation: Any): DependencyConstraint? =
        add("testRuntimeOnlyDependenciesMetadata", constraintNotation)


    /**
     * Adds a dependency constraint to the 'testRuntimeOnlyDependenciesMetadata' configuration.
     *
     * @param constraintNotation the dependency constraint notation
     * @param block the block to use to configure the dependency constraint
     *
     * @return the added dependency constraint
     *
     * @see [DependencyConstraintHandler.add]
     */
    fun DependencyConstraintHandler.`testRuntimeOnlyDependenciesMetadata`(constraintNotation: Any, block: DependencyConstraint.() -> Unit): DependencyConstraint? =
        add("testRuntimeOnlyDependenciesMetadata", constraintNotation, block)


    /**
     * Adds an artifact to the 'testRuntimeOnlyDependenciesMetadata' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testRuntimeOnlyDependenciesMetadata`(artifactNotation: Any): PublishArtifact =
        add("testRuntimeOnlyDependenciesMetadata", artifactNotation)


    /**
     * Adds an artifact to the 'testRuntimeOnlyDependenciesMetadata' configuration.
     *
     * @param artifactNotation the group of the module to be added as a dependency.
     * @param configureAction The action to execute to configure the artifact.
     * @return The artifact.
     *
     * @see [ArtifactHandler.add]
     */
    fun ArtifactHandler.`testRuntimeOnlyDependenciesMetadata`(
        artifactNotation: Any,
        configureAction:  ConfigurablePublishArtifact.() -> Unit): PublishArtifact =
            add("testRuntimeOnlyDependenciesMetadata", artifactNotation, configureAction)


BUILD SUCCESSFUL in 4s
1 actionable task: 1 executed
